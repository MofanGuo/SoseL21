package SoseL21.editor;

/*Generated by MPS */

import com.mbeddr.mpsutil.grammarcells.runtime.AbstractGrammarActionDescriptor;
import com.mbeddr.mpsutil.grammarcells.runtime.IGrammarActionsDescriptor;
import java.util.List;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuItem;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuContext;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import jetbrains.mps.lang.editor.menus.substitute.DefaultSubstituteMenuLookup;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.editor.menus.substitute.ReferenceScopeSubstituteMenuItem;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.editor.menus.substitute.SubstituteMenuItemWrapper;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSubstituteMenuItem;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.lang.editor.menus.transformation.MenuLocations;
import com.mbeddr.mpsutil.grammarcells.runtime.Parser;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.constraints.ConstraintsCanBeFacade;
import jetbrains.mps.core.aspects.constraints.rules.kinds.ContainmentContext;
import com.mbeddr.mpsutil.grammarcells.runtime.MultiTextActionItem;
import jetbrains.mps.smodel.presentation.NodePresentationUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import com.mbeddr.mpsutil.grammarcells.runtime.SavedCaretPosition;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.action.NodeSubstituteActionsFactoryContext;
import com.mbeddr.mpsutil.grammarcells.runtime.IToken;
import com.mbeddr.mpsutil.grammarcells.runtime.ISymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.ChildSymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.SyntaxMatcher;
import com.mbeddr.mpsutil.grammarcells.runtime.MultiTextSubsituteAction;
import com.mbeddr.mpsutil.grammarcells.runtime.IRule;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import com.mbeddr.mpsutil.grammarcells.runtime.AbstractRule;
import com.mbeddr.mpsutil.grammarcells.runtime.ConstantSymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.PropertySymbol;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class GrammarActionsDescriptor extends AbstractGrammarActionDescriptor implements IGrammarActionsDescriptor {

  public static final GrammarActionsDescriptor INSTANCE = new GrammarActionsDescriptor();

  @Override
  public List<SubstituteMenuItem> getActions(final SubstituteMenuContext _context, final SAbstractConcept expectedOutputConceptExactly) {
    final List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("SoseL21.editor.GrammarActionsDescriptor.getActions", null));
    try {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ExpressionStatementContent", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130661679420")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.ExpressionStatementContent$5s)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$Yb;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ExpressionStatementContent$5s, _context.getModel(), ExpressionStatementContent_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.expression$_J0y).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.expression$_J0y, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$Yb));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryInteger", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130662566821")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BinaryInteger$dJ)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IntegerExpression$4G;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryInteger$dJ, _context.getModel(), BinaryInteger_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.first$oXey).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.first$oXey, SNodeOperations.cast(nodeToWrap, CONCEPTS.IntegerExpression$4G));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryInteger", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130662567174")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BinaryInteger$dJ)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IntegerExpression$4G;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryInteger$dJ, _context.getModel(), BinaryInteger_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.second$p2BT).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.second$p2BT, SNodeOperations.cast(nodeToWrap, CONCEPTS.IntegerExpression$4G));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "IntegerLetter", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130662234382")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.IntegerLetter$ij)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.IntegerLetter$ij, _context.getModel(), IntegerLetter_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.value$dkY0;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.value$dkY0, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        super.select(newNode, pattern);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.IntegerLetter$ij;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryBoolean", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "2848645869253781568")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BinaryBoolean$bW)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IntegerExpression$4G;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryBoolean$bW, _context.getModel(), BinaryBoolean_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.first$1VSY).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.first$1VSY, SNodeOperations.cast(nodeToWrap, CONCEPTS.IntegerExpression$4G));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryBoolean", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "2848645869253781913")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BinaryBoolean$bW)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IntegerExpression$4G;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryBoolean$bW, _context.getModel(), BinaryBoolean_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.second$1Wn0).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.second$1Wn0, SNodeOperations.cast(nodeToWrap, CONCEPTS.IntegerExpression$4G));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BooleanLetter", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "2848645869253787873")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BooleanLetter$U)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BooleanLetter$U, _context.getModel(), BooleanLetter_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.value$Fchw;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.value$Fchw, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        super.select(newNode, pattern);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.BooleanLetter$U;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
      public boolean accept(SubstituteMenuItem it) {
        return it != null;
      }
    }).toListSequence();
  }

  @Override
  protected List<TransformationMenuItem> doGetSideTransformActions(final TransformationMenuContext _context) {
    final List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("SoseL21.editor.GrammarActionsDescriptor.doGetSideTransformActions", null));
    try {
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ExpressionStatementContent", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130661679420")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$Yb, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ExpressionStatementContent$5s, _context.getModel(), ExpressionStatementContent_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton(";");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.ExpressionStatementContent$5s);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expression$_J0y, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$Yb));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryInteger", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130662566821")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IntegerExpression$4G, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryInteger$dJ, _context.getModel(), BinaryInteger_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.BinaryInteger$dJ);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.first$oXey, SNodeOperations.cast(sourceNode, CONCEPTS.IntegerExpression$4G));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryInteger", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130662567174")));
              try {
                if (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IntegerExpression$4G, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryInteger$dJ, _context.getModel(), BinaryInteger_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.BinaryInteger$dJ);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.second$p2BT, SNodeOperations.cast(sourceNode, CONCEPTS.IntegerExpression$4G));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "IntegerLetter", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "5956875130662234382")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryBoolean", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "2848645869253781568")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IntegerExpression$4G, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryBoolean$bW, _context.getModel(), BinaryBoolean_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.BinaryBoolean$bW);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.first$1VSY, SNodeOperations.cast(sourceNode, CONCEPTS.IntegerExpression$4G));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryBoolean", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "2848645869253781913")));
              try {
                if (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IntegerExpression$4G, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryBoolean$bW, _context.getModel(), BinaryBoolean_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.BinaryBoolean$bW);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.second$1Wn0, SNodeOperations.cast(sourceNode, CONCEPTS.IntegerExpression$4G));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BooleanLetter", new SNodePointer("r:822144c8-f35c-4bba-91f2-0cbb647dda23(SoseL21.editor)", "2848645869253787873")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
      public boolean accept(TransformationMenuItem it) {
        return it != null;
      }
    }).toListSequence();
  }

  @Override
  public List<SubstituteAction> getConstantReplaceActions(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context, final List<IToken> elementsBefore, final List<IToken> elementsAfter) {
    final List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());

    // BinaryInteger_Editor
    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryInteger$dJ, _context.getModel(), BinaryInteger_Editor.class)) {

      final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
        public String query(SAbstractConcept subconcept) {
          return SConceptOperations.conceptAlias(subconcept);
        }
      }.query(subconcept))).where(new IWhereFilter<String>() {
        public boolean accept(String it) {
          return (it != null && it.length() > 0);
        }
      });
      boolean conceptAllowed = SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(_context.getChildConcept()));
      SNode sourceNode = _context.getCurrentTargetNode();
      boolean transformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(_context.getParentNode()).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
      transformationEnabled &= GrammarCellsUtil.canBeAncestor(_context.getParentNode(), subconcept, sourceNode.getContainmentLink());
      if (Sequence.fromIterable(matchingText).isNotEmpty() && conceptAllowed && transformationEnabled) {

        final List<ISymbol> beforeMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        final List<ISymbol> afterMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        ListSequence.fromList(beforeMatchers).addElement(new ChildSymbol(LINKS.first$oXey));
        ListSequence.fromList(afterMatchers).addElement(new ChildSymbol(LINKS.second$p2BT));
        final SyntaxMatcher matcher = new SyntaxMatcher();
        if (matcher.matches(elementsBefore, beforeMatchers, false, null) && matcher.matches(elementsAfter, afterMatchers, false, null)) {

          ListSequence.fromList(result).addElement(new MultiTextSubsituteAction(_context.getParentNode(), matchingText) {
            public String getDescriptionText(String pattern) {
              String shortDescription = subconcept.getShortDescription();
              return (shortDescription != null ? shortDescription : subconcept.getName());
            }
            @Override
            protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
              SNode newNode = SNodeFactoryOperations.createNewNode(subconcept, null);

              matcher.matches(elementsBefore, beforeMatchers, true, newNode);
              matcher.matches(elementsAfter, afterMatchers, true, newNode);

              _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), newNode, editorContext);

              GrammarCellsUtil.selectCellWithText(editorContext, newNode, getMatchingText(pattern));

              SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
              caretPosition.save();
              Parser parser = new Parser(editorContext.getModel());
              SNode expressionRoot = parser.findRootExpression(newNode);
              parser.rebalanceIfRequired(expressionRoot);
              caretPosition.restore();

              return null;
            }
            @Override
            public SNode getOutputConcept() {
              return SNodeOperations.asNode(subconcept);
            }
          });
        }
      }
    }




    return ListSequence.fromList(result).where(new IWhereFilter<SubstituteAction>() {
      public boolean accept(SubstituteAction it) {
        return it != null;
      }
    }).toListSequence();
  }

  @Override
  public List<IRule> getRules(final SModel contextModel) {
    final List<IRule> rules = ListSequence.fromList(new ArrayList<IRule>());

    final Set<SLanguage> visibleLanguages = GrammarCellsUtil.getVisibleLanguages(contextModel);

    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryInteger$dJ, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.first$oXey));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(new Object() {
              public String query(SAbstractConcept subconcept) {
                return SConceptOperations.conceptAlias(subconcept);
              }
            }.query(subconcept)));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.second$p2BT));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.BinaryInteger$dJ;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ParenExpression$_F, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ConstantSymbol("("));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.expression$dz_l));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(")"));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.ParenExpression$_F;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.IntegerLetter$ij, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new PropertySymbol(CONCEPTS.IntegerLetter$ij, PROPS.value$dkY0));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.IntegerLetter$ij;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryBoolean$bW, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.first$1VSY));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(new Object() {
              public String query(SAbstractConcept subconcept) {
                return SConceptOperations.conceptAlias(subconcept);
              }
            }.query(subconcept)));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.second$1Wn0));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.BinaryBoolean$bW;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
        });
      }
    }

    return rules;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Expression$Yb = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x550d21c8a2e5f49L, "SoseL21.structure.Expression");
    /*package*/ static final SConcept ExpressionStatementContent$5s = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x403c8839c2edc924L, "SoseL21.structure.ExpressionStatementContent");
    /*package*/ static final SConcept IntegerExpression$4G = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x403c8839c2e6bde4L, "SoseL21.structure.IntegerExpression");
    /*package*/ static final SConcept BinaryInteger$dJ = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x52ab125ed6750519L, "SoseL21.structure.BinaryInteger");
    /*package*/ static final SConcept IntegerLetter$ij = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x52ab125ed67b2894L, "SoseL21.structure.IntegerLetter");
    /*package*/ static final SConcept BinaryBoolean$bW = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x27886c5347c15db5L, "SoseL21.structure.BinaryBoolean");
    /*package*/ static final SConcept BooleanLetter$U = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x27886c5347c180d2L, "SoseL21.structure.BooleanLetter");
    /*package*/ static final SConcept ParenExpression$_F = MetaAdapterFactory.getConcept(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x52ab125ed67b28a7L, "SoseL21.structure.ParenExpression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink expression$_J0y = MetaAdapterFactory.getContainmentLink(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x403c8839c2edc924L, 0x403c8839c2edc927L, "expression");
    /*package*/ static final SContainmentLink first$oXey = MetaAdapterFactory.getContainmentLink(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x52ab125ed6750519L, 0x52ab125ed67507dcL, "first");
    /*package*/ static final SContainmentLink second$p2BT = MetaAdapterFactory.getContainmentLink(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x52ab125ed6750519L, 0x52ab125ed67507deL, "second");
    /*package*/ static final SContainmentLink first$1VSY = MetaAdapterFactory.getContainmentLink(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x27886c5347c15db5L, 0x27886c5347c16539L, "first");
    /*package*/ static final SContainmentLink second$1Wn0 = MetaAdapterFactory.getContainmentLink(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x27886c5347c15db5L, 0x27886c5347c1653bL, "second");
    /*package*/ static final SContainmentLink expression$dz_l = MetaAdapterFactory.getContainmentLink(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x52ab125ed67b28a7L, 0x52ab125ed67b28a8L, "expression");
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$dkY0 = MetaAdapterFactory.getProperty(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x52ab125ed67b2894L, 0x52ab125ed67b2895L, "value");
    /*package*/ static final SProperty value$Fchw = MetaAdapterFactory.getProperty(0x553bdaad1cb3493bL, 0xaccb16ef149d741aL, 0x27886c5347c180d2L, 0x27886c5347c180d3L, "value");
  }
}
